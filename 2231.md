### 백준 2231번
=================================

### 난이도 - 브론즈2

<hr>

### 문제 설명
부분합 중 최소 값 구하기!
ex) 198 + 1 + 9 + 8 = 216
216의 부분합은 198 207도 부분합 이지만 최소 부분합은 198이다.

### 소스 코드
+ 메모리 : 30840 KB
+ 시간 : 68 ms

```python
n = int(input())
n_li = []
n_mi = []

for i in str(n):
    n_li.append(int(i))

for i in range(1, (len(n_li)*9)+1):
    di = n - i
    sum = 0
    if di == 0:
        break
    for j in str(di):
        n_li.append(int(j))
        sum += int(j)
    if di + sum == n:
        n_mi.append(di)

if len(n_mi) >= 1:
    print(min(n_mi))
elif not n_mi or di == 0:
    print(0)
```
### 코드설명
+ 첫번째 for 문은 입력받은 n을 각 자리수를 리스트로 나눈다.
+ 부분합은 결국 n > 부분합(di) > n-각자리수*9 이기 때문에 for 문으로 n - 1 부터 n - 각자리수*9 까지 빼는 것을 반복한다.
+ 반복 중에 di == 0 이면 부분합이 존재하지 않으므로 반복을 종료한다.
+ di 와 di의 각자리수 를 더했을 때 n 이면 그 di는 n의 부분합이 된다. 빈 리스트에 부분합을 추가한다. (부분합이 여러개 일 수 있으므로 추가)
+ 추가된 부분합이 없거나 di == 0 이면 부분합은 존재 하지 않으므로 0 출력
+ 추가된 부분합이 있다면 그 리스트의 최소값을 출력

### 주요한 점
부분합이 존재 할 수 있는 최소의 수 부터 최대의 수 까지 고려하여
반복을 진행하는 것이 가장 주요했던 듯 하다.
결국 각 자리수의 가장 큰 값인 9를 자릿수 만큼 뺀 수부터 고려한 것.

.. 브론즈 2치고는 애를 먹었다..!