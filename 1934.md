### 백준 1934번
=================================

### 난이도 - 브론즈1

<hr>

### 문제 설명
테스트 케이스 수를 입력받고
테스트 케이스 만큼 두 수를 입력받아
각각의 두 수의 최소 공배수 구하기

### 소스 코드
+ 메모리 : 30840 KB
+ 시간 : 160 ms

```python
t = int(input())

for i in range(t):
    a, b = map(int, input().split())
    nodeno1, nodeno2 = a, b
    if a > b:
        while a*b != 0:
            a, b = b, a % b
        print(int((nodeno1/a)*nodeno2))
    else:
        while a*b != 0:
            b, a = a, b % a
        print(int((nodeno1/b)*nodeno2))
```
### 사고과정
(먼저 최대공약수에 대해 생각해보았다. 공통된 인수를 전부 곱한 것이기 때문에, a와 b 중 큰 수 부터 -1 씩 해 가면서 두 수에 나눴을 때 각각 나누어 떨어지는 가장 큰 수가 최대공약수로 두었다.

최소공배수는 최대공약수x서로소 임을 고려하여

a/최대공약수 X b/최대공약수 X 최대공약수 로 구현하였다.)

까지가 어제 풀었던 최소공배수 최대공약수 문제였다. 사실 어느정도 비슷한 맥락이었다.
어제는 그냥 나의 쌩 계산으로 풀었고 오늘은 대학교 자료구조 강의 때 들었던
유클리드의 gcd 알고리즘을 고려하여 풀어보았다.
### 코드설명
코드 자체는 매우 쉬움
+ 시간 복잡도 $$O(nlogn)$$
으로 추측